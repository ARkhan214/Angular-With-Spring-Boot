
http://localhost:8085/api/user/
@CrossOrigin(origins = "http://localhost:4200")

farihamariam@gmail.com
==>json form
{
  "name": "CM Reja",
  "email": "cmrejaulkarim@gmail.com",
  "password": "12345",
  "phoneNumber": "01735473348",
  "dateOfBirth": "1990-01-01"
}
{
  "name": "CM Reja",
  "accountActiveStatus": true,
  "accountType": "SAVINGS",
  "balance": 5000.0,
  "nid": "1234567890123",
  "phoneNumber": "01735473348",
  "address": "Dhaka, Bangladesh",
  "dateOfBirth": "1990-01-01",
  "accountOpeningDate": "2025-08-16",
  "accountClosingDate": null,
  "role": "USER"
}












//me
user
{
  "name": "Md Rahim Khan",
  "email": "mdrahimkhan107107@gmail.com",
  "password": "12345" 
}

account
{
  "type": "SAVINGS",
  "balance": 15000.50,
  "userName": "Md Rahim Khan",
  "activeStatus": true 
}


//reja
user
{
  "name": "Reja",
  "email": "cmrejaulkarim@gmail.com",
  "password": "12345" 
}

account
{
  "type": "SAVINGS",
  "balance": 15000.50,
  "userName": "Reja",
  "activeStatus": true 
}

//sathe
user
{
  "name": "Sathe",
  "email": "sathekhanom550@gmail.com",
  "password": "12345" 
}

account
{
  "type": "SAVINGS",
  "balance": 15000.50,
  "userName": "Sathe",
  "activeStatus": true 
}


//sadier
user
{
  "name": "Sadier Rahman",
  "email": "sadiar.rahman970@gmail.com",
  "password": "12345" 
}

account
{
  "type": "SAVINGS",
  "balance": 15000.50,
  "userName": "Sadier Rahman",
  "activeStatus": true 
}

//Emran Mia
user
{
  "name": "Emran Mia",
  "email": "mr.t.imran11@gmail.com",
  "password": "12345",
  "account_id":"6" 
}

account
{
  "type": "SAVINGS",
  "balance": 15000.50,
  "userName": "Sadier Rahman",
  "activeStatus": true 
}


//UserRestController
//first a airokom silo
 @PostMapping
    public ResponseEntity<Map<String,String>>saveUser(
            @RequestPart(value = "user")String userJson,
            @RequestParam(value = "photo")MultipartFile file
            ) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        User user = objectMapper.readValue(userJson, User.class);

        try {
            authService.saveOrUpdateUser(user, file);
            Map<String, String> response = new HashMap<>();
            response.put("Message", "User Added Successfully ");

            return new ResponseEntity<>(response, HttpStatus.OK);
        } catch (Exception e) {

            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("Message", "User Add Faild " + e);
            return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }



//UserRestController
//Second a airokom silo
 @PostMapping
    public ResponseEntity<Map<String,String>>saveUser(
            @RequestPart(value = "user")String userJson,
	    @RequestPart(value = "account")String accountJson,
            @RequestParam(value = "photo")MultipartFile file
            ) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        User user = objectMapper.readValue(userJson, User.class);
 	Accounts accounts = objectMapper.readValue(accountJson, Accounts.class);

        try {
            authService.registerAccount(user, file, accounts);
            Map<String, String> response = new HashMap<>();
            response.put("Message", "User Added Successfully ");

            return new ResponseEntity<>(response, HttpStatus.OK);
        } catch (Exception e) {

            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("Message", "User Add Faild " + e);
            return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }


























package com.emranhss.mkbankspring.restcontroller;

import com.emranhss.mkbankspring.entity.Accounts;
import com.emranhss.mkbankspring.entity.Transaction;
import com.emranhss.mkbankspring.repository.AccountRepository;
import com.emranhss.mkbankspring.service.TransactionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/transactions")
@CrossOrigin("*")
public class TransactionRestController {

    private final TransactionService transactionService;

    @Autowired
    private AccountRepository accountRepository;

    public TransactionRestController(TransactionService transactionService){
        this.transactionService = transactionService;
    }

    // Save new transaction
    @PostMapping
    public ResponseEntity<Transaction> addTransaction(@RequestBody Transaction transaction){
        Transaction savedTransaction = transactionService.saveTransaction(transaction);
        return ResponseEntity.ok(savedTransaction);
    }

    // Get all transactions
    @GetMapping
    public ResponseEntity<List<Transaction>> getAllTransactions(){
        List<Transaction> transactions = transactionService.getAllTransactions();
        return ResponseEntity.ok(transactions);
    }

    // Get transactions by account ID
    @GetMapping("/account/{accountId}")
    public ResponseEntity<List<Transaction>> getTransactionsByAccount(@PathVariable Long accountId){
        List<Transaction> transactions = transactionService.getTransactionsByAccountId(accountId);
        return ResponseEntity.ok(transactions);
    }

    // Get transactions by type
    @GetMapping("/type/{type}")
    public ResponseEntity<List<Transaction>> getTransactionsByType(@PathVariable String type){
        List<Transaction> transactions = transactionService.getTransactionsByType(type);
        return ResponseEntity.ok(transactions);
    }


    @PostMapping
    public Transaction createTransaction(@RequestBody Transaction transaction) {
        return transactionService.addTransaction(transaction);
    }

    @GetMapping
    public List<Transaction> getTransactions(@RequestParam(required = false) Long accountId) {
        if (accountId != null) {
            Accounts account = accountRepository.findById(accountId)
                    .orElseThrow(() -> new RuntimeException("Account not found"));
            return transactionService.getTransactionsByAccount(account);
        }
        return transactionService.getAllTransactions();
    }


}



















TransactionService
package com.emranhss.mkbankspring.service;

import com.emranhss.mkbankspring.entity.Accounts;
import com.emranhss.mkbankspring.entity.Transaction;
import com.emranhss.mkbankspring.entity.TransactionType;
import com.emranhss.mkbankspring.repository.AccountRepository;
import com.emranhss.mkbankspring.repository.TransactionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.List;
import java.util.Optional;
   
@Service
public class TransactionService {

    @Autowired
    private TransactionRepository transactionRepository;
    @Autowired
    private AccountRepository accountRepository;

//    @Autowired
//    public TransactionService(TransactionRepository transactionRepository,
//                              AccountRepository accountRepository){
//        this.transactionRepository = transactionRepository;
//        this.accountRepository = accountRepository;
//    }

    // Save or update transaction
    public Transaction saveTransaction(Transaction transaction){
        return transactionRepository.save(transaction);
    }

    // Get all transactions
    public List<Transaction> getAllTransactions(){
        return transactionRepository.findAll();
    }

    // Get transactions by accountId
    public List<Transaction> getTransactionsByAccountId(Long accountId){
        return transactionRepository.findByAccountId(accountId);
    }

    // Get transactions by type
    public List<Transaction> getTransactionsByType(String type){
        return transactionRepository.findByType(type);
    }

    // Optional: Get transaction by Id
    public Optional<Transaction> getTransactionById(Long id){
        return transactionRepository.findById(id);
    }

    public Transaction findByReceverId(Long id){
      return transactionRepository.findById(id).orElse(null);
    }
}

    // for save Transaction process.It will  handle Deposit, Withdraw, Transfer and balance update + transaction save
    public Transaction addTransaction(Transaction transaction) {

        Accounts sender = transaction.getAccount();
        if (!sender.isAccountActiveStatus()) {
            throw new RuntimeException("Sender account is closed!");
        }



        double newBalance = sender.getBalance();

        if (transaction.getType() == TransactionType.DEPOSIT) {
            newBalance += transaction.getAmount();
        } else if (transaction.getType() == TransactionType.WITHDRAW) {
            if (transaction.getAmount() > newBalance) {
                throw new RuntimeException("Insufficient balance!");
            }
            newBalance -= transaction.getAmount();
        }



        return newBalance;
    }



// Get transactions by Accounts object
    public List<Transaction> getTransactionsByAccount(Accounts account) {
        return transactionRepository.findByAccount(account);
    }

    // Get transactions by account + date range
    public List<Transaction> getTransactionsByAccountAndDateRange(Long accountId, Date start, Date end){
        return transactionRepository.findByAccountIdAndTransactionTimeBetweenOrderByTransactionTimeAsc(accountId, start, end);
    }


}





addTransactionWithBalance(transaction: Transaction): Observable<any> {  
    const accountId = transaction.accountId;

    console.log(accountId);

    return this.http.get<Accounts>(`${this.apiUrl}/${accountId}`).pipe(
      
      switchMap(account => {
        if (!account) {
          return throwError(() => new Error('Account not found!'));
        }

         //new code for status
      if (account.accountActiveStatus === false) {
        return throwError(() => new Error('This account is closed and cannot perform transactions.'));
      }

        let newBalance = account.balance || 0;
        console.log(accountId);

        if (transaction.type === 'DEPOSIT') {
          newBalance += transaction.amount;
        } else if (transaction.type === 'WITHDRAW') {
          if (transaction.amount > newBalance) {
            return throwError(() => new Error('Insufficient balance!'));
          }
          newBalance -= transaction.amount;
        }

        else if (transaction.type === 'TRANSFER') {
          if (transaction.amount > newBalance) {
            return throwError(() => new Error('Insufficient balance!'));
          }

          // Sender balance minus
          newBalance -= transaction.amount;

          // Find Receiver account and incarage balance
          const receiverId = transaction.receiverAccountId;

          this.http.get<Accounts>(`${this.apiUrl}/${receiverId}`).subscribe(receiverAccount => {
            
            const updatedReceiver = {
              ...receiverAccount,
              balance: receiverAccount.balance + transaction.amount
            };

            // update Receiver- balance
            this.http.put(`${this.apiUrl}/${receiverId}`, updatedReceiver).subscribe({
              next: () => {
                console.log('Receiver balance updated!');
              },
              error: err => {
                console.error('Receiver update failed:', err);
              }
            });
          }, error => {
            console.error('Receiver not found:', error);
          });
        }
       
        // Update account balance
        const updatedAccount: Accounts = { ...account, balance: newBalance };

        return this.http.put<Accounts>(`${this.apiUrl}/${accountId}`, updatedAccount).pipe(
          switchMap(() => {
            return this.http.post<Transaction>(this.transactionsUrl, transaction);
          })
        );
     })
    );

  }
